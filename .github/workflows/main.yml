name: Mas

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build:
    name: Построение и настройка системы
    runs-on: windows-2022

    env:
      NGROK_AUTH_TOKEN: ${{ secrets.NGROK_AUTH_TOKEN }}
      RUNNER_ADMIN_PASSWORD: ${{ secrets.RUNNER_ADMIN_PASSWORD }}

    steps:
      # Шаг 1: Проверка кода репозитория
      - name: Checkout repository
        uses: actions/checkout@v3

      # Шаг 2: Настройка PowerShell Core (если требуется)
      - name: Setup PowerShell
        uses: PowerShell/setup-powershell@v1
        with:
          version: '7.3.5'  # Укажите нужную версию PowerShell

      # Шаг 3: Скачать ngrok
      - name: Download ngrok
        run: |
          if (-Not (Test-Path -Path "./ngrok")) {
            Invoke-WebRequest https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-v3-stable-windows-amd64.zip -OutFile ngrok.zip
          } else {
            Write-Output "ngrok уже загружен."
          }
        shell: pwsh

      # Шаг 4: Распаковать ngrok
      - name: Extract ngrok
        run: |
          if (-Not (Test-Path -Path "./ngrok/ngrok.exe")) {
            Expand-Archive ngrok.zip -DestinationPath .\ngrok
          } else {
            Write-Output "ngrok уже распакован."
          }
        shell: pwsh

      # Шаг 5: Аутентификация ngrok
      - name: Authenticate ngrok
        run: .\ngrok\ngrok.exe authtoken $Env:NGROK_AUTH_TOKEN
        shell: pwsh

      # Шаг 6: Настройка DNS на Cloudflare
      - name: Set DNS to Cloudflare
        run: |
          try {
            $adapters = Get-NetAdapter | Where-Object { $_.Status -eq 'Up' }
            foreach ($adapter in $adapters) {
              Set-DnsClientServerAddress -InterfaceIndex $adapter.InterfaceIndex -ServerAddresses @("1.1.1.1","1.0.0.1")
              Write-Output "DNS установлен для адаптера: $($adapter.Name)"
            }
          } catch {
            Write-Error "Ошибка при настройке DNS: $_"
            exit 1
          }
        shell: pwsh

      # Шаг 7: Оптимизация производительности системы
      - name: Optimize System Performance
        run: |
          try {
            # Установка плана электропитания на Высокую производительность
            powercfg -setactive SCHEME_MIN
            Write-Output "План электропитания установлен на Высокую производительность."

            # Отключение анимаций и эффектов для повышения производительности
            Set-ItemProperty -Path 'HKCU:\Control Panel\Desktop' -Name 'WindowMetrics' -Value ''
            Set-ItemProperty -Path 'HKCU:\Control Panel\Desktop\WindowMetrics' -Name 'MinAnimate' -Value 0
            Write-Output "Анимации и эффекты отключены."

            # Отключение неиспользуемых сервисов
            $services = @("SysMain", "Spooler")
            foreach ($service in $services) {
              if (Get-Service -Name $service -ErrorAction SilentlyContinue) {
                Stop-Service -Name $service -Force
                Set-Service -Name $service -StartupType Disabled
                Write-Output "Сервис $service отключен."
              }
            }
          } catch {
            Write-Error "Ошибка при оптимизации системы: $_"
            exit 1
          }
        shell: pwsh

      # Шаг 8: Включение Remote Desktop и создание пользователя
      - name: Enable Remote Desktop and Create User
        run: |
          try {
            # Разрешение подключений через RDP
            Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name "fDenyTSConnections" -Value 0
            Enable-NetFirewallRule -DisplayGroup "Remote Desktop"
            Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "UserAuthentication" -Value 1
            Write-Output "Remote Desktop разрешен."

            # Проверка, существует ли пользователь 'runneradmin'
            $userExists = Get-LocalUser -Name "runneradmin" -ErrorAction SilentlyContinue
            if (-not $userExists) {
              Write-Output "Создание нового пользователя 'runneradmin'."
              $password = ConvertTo-SecureString $env:RUNNER_ADMIN_PASSWORD -AsPlainText -Force
              New-LocalUser -Name "runneradmin" -Password $password -FullName "Runner Admin" -Description "Admin user for RDP access"
              Add-LocalGroupMember -Group "Administrators" -Member "runneradmin"
              Write-Output "Пользователь 'runneradmin' создан и добавлен в группу 'Administrators'."
            } else {
              Write-Output "Пользователь 'runneradmin' уже существует. Обновление пароля."
              $password = ConvertTo-SecureString $env:RUNNER_ADMIN_PASSWORD -AsPlainText -Force
              Set-LocalUser -Name "runneradmin" -Password $password

              # Убедимся, что пользователь принадлежит к группе "Administrators"
              $isMember = Get-LocalGroupMember -Group "Administrators" -Member "runneradmin" -ErrorAction SilentlyContinue
              if (-not $isMember) {
                Write-Output "Добавление пользователя 'runneradmin' в группу 'Administrators'."
                Add-LocalGroupMember -Group "Administrators" -Member "runneradmin"
              } else {
                Write-Output "Пользователь 'runneradmin' уже является членом группы 'Administrators'."
              }
            }
          } catch {
            Write-Error "Ошибка при настройке RDP или создании пользователя: $_"
            exit 1
          }
        shell: pwsh

      # Шаг 9: Создание туннеля ngrok для RDP
      - name: Create ngrok Tunnel for RDP
        run: |
          try {
            Start-Process -NoNewWindow -FilePath ".\ngrok\ngrok.exe" -ArgumentList "tcp 3389" -PassThru | Out-Null
            Write-Output "ngrok туннель для RDP создан."
          } catch {
            Write-Error "Ошибка при создании ngrok туннеля: $_"
            exit 1
          }
        shell: pwsh

      # Шаг 10: Отображение информации о туннеле ngrok
      - name: Display ngrok Tunnel Information
        run: |
          Start-Sleep -Seconds 15
          $tunnelInfo = .\ngrok\ngrok.exe tcp 3389 --log=stdout | Select-String "tcp://"
          if ($tunnelInfo) {
            Write-Output "Информация о туннеле ngrok:"
            Write-Output $tunnelInfo
          } else {
            Write-Error "Не удалось получить информацию о туннеле ngrok."
            exit 1
          }
        shell: pwsh

      # Шаг 11: Очистка временных файлов
      - name: Cleanup Temporary Files
        run: |
          Remove-Item -Path "ngrok.zip" -ErrorAction SilentlyContinue
          Remove-Item -Path "./ngrok" -Recurse -Force -ErrorAction SilentlyContinue
          Write-Output "Временные файлы очищены."
        shell: pwsh

      # Шаг 12: Уведомление о завершении
      - name: Notify Completion
        if: success()
        run: Write-Output "Workflow успешно завершен."
        shell: pwsh

      - name: Notify Failure
        if: failure()
        run: Write-Error "Workflow завершился с ошибкой."
        shell: pwsh
